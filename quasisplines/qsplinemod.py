r"""

Quasispline Module Generators

This module produces generators for the quasispline module given ideal difference conditions.

The generators are produced using the Groebner basis algorithm found by Patrick Clarke. 
This means an auxiliary ring is introduced with two ideals G & M. 
Generators for G with remainders in M are naturally identified with quasispline module generators.

EXAMPLES::

    sage: XXX

"""

# This file was *autogenerated* from the file qsplinemod.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)#******** MAIN ROUTINES ********* 
#spline_module_generators -> OAey, OA_to_tuple 
#short spline_module_generators -> OAey, OA_to_tuple 

#spline_ring_generators #This should go in the rings module

#************* dependancies ***************
#OAey -> G_ideal
#OA_to_tuple -> G_ideal

#G_ideal -> M_ideal

############### generators of the spline R-module and ring.  ######################
##### also a possibly expensive routine to try to find small generating sets #############

def spline_module_generators(R, s, J):
    r"""
    Returns spline module generators as tuples.
    """
    (OA, e, y) = OAey(R, s) #e's are the 'standard basis' variables, y's are the R variables
    zero_tuple = tuple([_sage_const_0  for i in range(s)])
    OA_to_R = OA.hom(list(zero_tuple)+list(R.gens()), R) #kills the e's and sends y's to R variables
    G = G_ideal(R, s, J)
    Grgb = G.groebner_basis()
    long_list = [OA_to_tuple(g, R, s)  for g in Grgb]
    return [g for g in long_list if not (g == zero_tuple)]

def short_spline_module_generators(R, s, J):
    r"""
    Returns minimal-ish set of spline module generators as tuples. 
    This uses potentially expensive/buggy groebner fan routines.
    """
    (OA, e, y) = OAey(R, s) #e's are the 'standard basis' variables, y's are the R variables
    zero_tuple = tuple([_sage_const_0  for i in range(s)])
    OA_to_R = OA.hom(list(zero_tuple)+list(R.gens()), R) #kills the e's and sends y's to R variables
    G = G_ideal(R, s, J)
    GF = G.groebner_fan() # groebner_fan routines seem to crap-out sometimes
    rGbs = GF.reduced_groebner_bases()
    long_lists = [[OA_to_tuple(g, R, s)  for g in rgb] for rgb in rGbs]
    smg_lists = [[g for g in long_list if not (g == zero_tuple)] for long_list in long_lists]
    shortlist = min(smg_lists, key = len)
    return shortlist

def spline_ring_generators(smg): #This should go in the rings module.
    r"""
    This gives spline ring generators as tuples. 
    These are just the spline module generators plus the identity tuple (1,...,1).
    """
    s = len(smg[_sage_const_0 ])
    one = tuple([_sage_const_1  for i in range(s)])
    srg = [generator for generator in smg if not (generator == one)]
    return srg


####################### The auxiliary ring OA and its special ideals G & M ##################
### the main purpose of OA is to compute the spline module generators ###

def OAey(R, s):
    r"""
    The auxiliary ring \mathcal{O}_A with coefficient and region variables.
    """
    n = len(R.gens())
    OA = PolynomialRing(QQ, 'a', s+n) # region variables first, then coefficient (R) variables.
    return (OA, OA.gens()[:s], OA.gens()[s:])

def OA_to_tuple(g, R, s):
    r"""
    Converts an element g of the auxiliary ring OA into a tuple-spline
    """
    (OA, e, y) = OAey(R, s)
    zero_list = [_sage_const_0  for i in range(s)]
    OA_to_R = OA.hom(zero_list+list(R.gens()), R)
    gt = tuple([OA_to_R(diff(g, e[i])) for i in range(s)])
    return gt

def tuple_to_OA(g):
    r"""
    Converts elements of the auxiliary ring OA into spline-region-index indexed tuples.
    """
    R = g[_sage_const_0 ].parent()
    (OA, e, y) = OAey(R, s)
    R_to_OA = R.hom(y, OA)
    ge = sum([R_to_OA(g[i]) *e[i] for i in range(s)])
    return ge

def G_ideal(R, s, J):
    r"""
    This is the ideal of  spline-region-indexed spline functions.
    Its quotient by the ideal of squares M_index gives the 'first-order thickening' functions.
    """
    (OA, e, y) = OAey(R, s)
    zero_list = [_sage_const_0  for i in range(s)]
    R_to_OA = R.hom(y, OA) #this corresponds to the projection from AsY to Y
    M = M_ideal(R, s)
    def jkfilter(j,k):
        return lambda x:((x !=e[j]) and (x !=e[k]))
    def GM(j,k):
        Jjk_in_OA = ideal([ R_to_OA(h) for h in J(j,k).gens()])
        if s<_sage_const_3 :
            return (M + Jjk_in_OA*ideal([e[j], e[k]]) + ideal(e[j]+e[k]))
        return (M + Jjk_in_OA*ideal([e[j], e[k]]) + ideal(e[j]+e[k]) + ideal(filter(jkfilter(j,k), e)))
    def intersect(I,J):
        return I.intersection(J)
    if s < _sage_const_3 :
        return GM(_sage_const_0 ,_sage_const_1 )
    G = reduce(intersect,[GM(j,k) for k in range(_sage_const_1 ,s) for j in range(k)])
    return G

def M_ideal(R, s):
    r"""
    This is the ideal of squares of the spline-region-index variables.
    """
    (OA, e, y) = OAey(R, s)
    M = ideal(e)**_sage_const_2 
    return M

#### expands a spline tuple as in terms of smg ####

def expand_spline(g, smg):
    r"""
    Takes tuple-spline and returns its expansion in smg.
    """
    Gsmg = ideal([tuple_to_OA(generator) for generator in smg]) #note: ideals remember generators
    expansion_coeffs= tuple_to_OA(g).lift(Gsmg) #lift gives coefficient of an expansion generators
    return expansion_coeffs

######## the routines below require that Barwick-Stone's QuillenSuslin package is installed  #######                                                                                                      
def is_projective(smg):
   mac2 = Macaulay2()
   mac2.eval('loadPackage "QuillenSuslin"; ')
   gen_matrix = matrix(smg).transpose()
   mGenMatrix = mac2(gen_matrix)
   mSmod = mGenMatrix.image()
   mSmodIsFree = mSmod.isProjective()
   S_mod_is_free = mSmodIsFree.to_sage()
   return S_mod_is_free

def compute_free_basis(smg):
   mac2 = Macaulay2()
   mac2.eval('loadPackage "QuillenSuslin"; ')
   gen_matrix = matrix(smg).transpose()
   mGenMatrix = mac2(gen_matrix)
   mSmod = mGenMatrix.image()
   mFreeBasis = mSmod.computeFreeBasis()
   free_basis_matrix = mFreeBasis.to_sage()
   free_basis = free_basis_matrix.columns()
   return free_basis


############# A Hilbert series routine for degree filtration #########################

def spline_Hilbert_series(R, s, J):
    G = G_ideal(R, s, J) #G_ideal is in qsplinemod.sage
    Ggb = G.groebner_basis()
    LTgens = [f.lt() for f in Ggb]
    M = M_ideal(R, s) #M_ideal is in qsplinemod.sage             
    LT = ideal(LTgens)+M
    LThs = LT.hilbert_series()
    t = LThs.parent().gens()[_sage_const_0 ]
    Mhs = M.hilbert_series()
    shs = (Mhs - LThs)/t
    return shs

def spline_Hilbert_polynomial(R,s,J):
    G = G_ideal(R, s, J) #G_ideal is in qsplinemod.sage                
    Ggb = G.groebner_basis()
    LTgens = [f.lt() for f in Ggb]
    M = M_ideal(R, s) #M_ideal is in qsplinemod.sage             
    LT = ideal(LTgens)+M
    LTp = LT.hilbert_polynomial()
    t = LTp.parent().gens()[_sage_const_0 ]
    Mp = M.hilbert_polynomial()
    P_diff = Mp-LTp
    P = P_diff(t = t+_sage_const_1 )
    return P


######################### Object Oriented Structures Here ################

class QuasiSplineModule:
    r"""
    Class for quasi-spline modules.
    """
    
    def __init__(self, splinemodgens):
        self._generators = splinemodgens #a list of tuples of base ring elements

    def generators(self):
        return self._generators

    def sheets(self):
        return len(self._generators[_sage_const_0 ])

    def base_ring(self):
        return self._generators[_sage_const_0 ][_sage_const_0 ].parent()

